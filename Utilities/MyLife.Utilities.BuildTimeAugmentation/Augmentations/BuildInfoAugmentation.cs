using System;
using System.Linq;
using System.Reflection;

using Microsoft.CodeAnalysis;


namespace MyLife.Utilities.BuildTimeAugmentation.Augmentations;


[Generator]
public sealed class BuildInfoAugmentation: IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterSourceOutput(context.CompilationProvider, (productionContext, compilationProvider) =>
		{
			var assemblyName = compilationProvider.AssemblyName;
			var compilerOptions = compilationProvider.Options;
			var assemblyVersion = compilationProvider.Assembly.GetAttributes()
				.Where(attr => attr.AttributeClass.Name.Equals(nameof(AssemblyVersionAttribute)))
				.First()?.ConstructorArguments[0].Value?.ToString() ?? string.Empty;

			var assemblyRootNamespace = assemblyName;

			var buildInfoSourceText = $@"// <auto-generated />
#pragma warning disable

using MyLife.Utilities;

namespace {assemblyName};

[global::System.CodeDom.Compiler.GeneratedCode(""{typeof(BuildInfoAugmentation).Assembly.GetName().Name}"", ""1.0.0.0"")]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public static class BuildConstants
{{
    public static BuildInformation BuildInfo = new()
	{{
		BuildTimestamp = {DateTimeOffset.UtcNow.ToUnixTimeSeconds()},
		BuildVersion = ""{assemblyVersion}"",
		BuildConfig = ""{compilerOptions.OptimizationLevel.ToString()}"",
		TargetPlatform = ""{compilerOptions.Platform.ToString()}""
	}};
}}
";

			productionContext.AddSource($"{assemblyName}.BuildConstants.g", buildInfoSourceText);
		});
	}
}

#region old
//[Generator]
//public class BuildInfoAugmentation: ISourceGenerator
//{
//	public void Initialize(GeneratorInitializationContext context)
//	{

//	}

//	public void Execute(GeneratorExecutionContext context)
//	{
//		static bool IsValidTypeDeclarationForAttribute(SyntaxNode node)
//			=> node.GetType().Equals(typeof(ClassDeclarationSyntax))
//				|| node.GetType().Equals(typeof(StructDeclarationSyntax))
//				|| node.GetType().Equals(typeof(RecordDeclarationSyntax));

//		var attributeSymbol = context.Compilation.GetTypeByMetadataName(typeof(AugmentBuildInfoAttribute).FullName);

//		var validTypesWithAttributesTrees = context.Compilation.SyntaxTrees
//			.Where(st => st.GetRoot().DescendantNodes().Where(IsValidTypeDeclarationForAttribute)
//				.Any(node => node.DescendantNodes().OfType<AttributeSyntax>().Any()));

//		foreach (var syntaxTree in validTypesWithAttributesTrees)
//		{
//			var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);

//			var validTypeNodes = syntaxTree.GetRoot().DescendantNodes().Where(IsValidTypeDeclarationForAttribute)
//				.Where(typeNode => typeNode.DescendantNodes().OfType<AttributeSyntax>()
//					.FirstOrDefault(attr => attr.DescendantTokens()
//						.Any(token 
//							=> token.IsKind(SyntaxKind.IdentifierToken) 
//								&& (semanticModel.GetTypeInfo(token.Parent).Type.Name == attributeSymbol.Name)
//						)
//					) != null
//				);

//			foreach (TypeDeclarationSyntax declaredTypeNode in validTypeNodes)
//			{
//				// syntaxTree.GetRoot().DescendantNodes().Where(IsValidTypeDeclarationForAttribute)
//				// .Where(typeNode => typeNode.DescendantNodes().OfType<AttributeSyntax>().Any())

//				//var nodes = declaredTypeNode
//				//	.DescendantNodes()
//				//	.OfType<AttributeSyntax>()
//				//	.FirstOrDefault(a => a.DescendantTokens()
//				//		.Any(token => token.IsKind(SyntaxKind.IdentifierToken) && semanticModel.GetTypeInfo(token.Parent).Type.Name == attributeSymbol.Name)
//				//	)?.DescendantTokens()?.Where(token => token.IsKind(SyntaxKind.IdentifierToken))?
//				//	.ToList() ?? [];

//				//if (nodes.Count == 0) continue;

//				// If we don't have a namespace at all we'll return an empty string
//				// This accounts for the "default namespace" case
//				var typeNamespace = string.Empty;

//				// Get the containing syntax node for the type declaration
//				// (could be a nested type, for example)
//				var potentialNamespaceParent = declaredTypeNode.Parent;

//				// Keep moving "out" of nested classes etc until we get to a namespace
//				// or until we run out of parents
//				while ((potentialNamespaceParent != null) &&
//						(potentialNamespaceParent is not NamespaceDeclarationSyntax)
//						&& (potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax))
//				{
//					potentialNamespaceParent = potentialNamespaceParent.Parent;
//				}

//				// Build up the final namespace by looping until we no longer have a namespace declaration
//				if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
//				{
//					// We have a namespace. Use that as the type
//					typeNamespace = namespaceParent.Name.ToString();

//					// Keep moving "out" of the namespace declarations until we 
//					// run out of nested namespace declarations
//					while (true)
//					{
//						if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
//						{
//							break;
//						}

//						// Add the outer namespace as a prefix to the final namespace
//						typeNamespace = $"{namespaceParent.Name}.{typeNamespace}";
//						namespaceParent = parent;
//					}
//				}

//				var nodeType = declaredTypeNode.Keyword.ValueText;
//				var typeName = declaredTypeNode.Identifier.ToString() + declaredTypeNode.TypeParameterList;
//				var typeModifiers = declaredTypeNode.Modifiers.Select(modifier => modifier.Text);
//				if (!typeModifiers.Contains("partial"))
//				{
//					// TODO: Report diagnostic

//					return;
//				}

//				var sourceText = SourceText.From($@"
//// <auto-generated />

//namespace {typeNamespace};

//{typeModifiers.Aggregate((all, next) => $"{all} {next}")} {nodeType} {typeName}
//{{
//    BuildInfo GetAssemblyBuildInfo()
//		=> new(
//			{DateTimeOffset.UtcNow.ToUnixTimeSeconds()},
//			{}
//		);
//}}", Encoding.UTF8);
//			}
//		}
//	}
//}
#endregion